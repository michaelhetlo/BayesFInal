---
title: "Project Checkpoint 3"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown


```{r}
# Load packages
library(bayesrules)
library(tidyverse)
library(rstanarm)
library(broom.mixed)
library(tidybayes)
library(forcats)
library(bayesplot)
library(lubridate)
library(nflfastR)
```


## Data Introduction

Our data comes Nflfastr. It is an R package that has scraped data into R to make it easier to create NFL analytics. The data includes play-by-play data from 1999 until the present. The package designer of is Maksim Horwitz. They use an API to directly scrape data from the NFL. This data was specifically collected to perform advanced analytics in the NFL. The NFL was and still is behind the other three major sports leagues in data sharing and analytics. 




# https://developer.nfl.com/get-started/overview

# https://www.kaggle.com/maxhorowitz/nflplaybyplay2009to2016

```{r}
data1 <- load_pbp(2019)
```



```{r}
dim(data1)
```

```{r}
names(data1)
```

```{r}
head(data1)
```

```{r}
summary(data1)
```


https://www.nflfastr.com/articles/field_descriptions.html


play_id	Numeric play id that when used with game_id and drive provides the unique identifier for a single play.
game_id	Ten digit identifier for NFL game.
old_game_id	Legacy NFL game ID.
home_team	String abbreviation for the home team.
away_team	String abbreviation for the away team.
season_type	'REG' or 'POST' indicating if the game belongs to regular or post season.
week	Season week.
posteam	String abbreviation for the team with possession.
posteam_type	String indicating whether the posteam team is home or away.
defteam	String abbreviation for the team on defense.
side_of_field	String abbreviation for which team's side of the field the team with possession is currently on.
yardline_100	Numeric distance in the number of yards from the opponent's endzone for the posteam.
game_date	Date of the game.
quarter_seconds_remaining	Numeric seconds remaining in the quarter.
half_seconds_remaining	Numeric seconds remaining in the half.
game_seconds_remaining	Numeric seconds remaining in the game.
game_half	String indicating which half the play is in, either Half1, Half2, or Overtime.
quarter_end - Binary indicator for whether or not the row of the data is marking the end of a quarter.
drive -	Numeric drive number in the game.
sp -	Binary indicator for whether or not a score occurred on the play.
qtr -	Quarter of the game (5 is overtime).
down -The down for the given play.
goal_to_go - Binary indicator for whether or not the posteam is in 





```{r, include = FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  comment = "#>"
)

with_dt <- requireNamespace("DT")

```

```{r eval = with_dt}
# DT::datatable(nflfastR::field_descriptions,options = list(scrollX = TRUE, pageLength = 372), filter = "top", rownames = FALSE)
```

```{r eval = with_dt}
knitr::kable(nflfastR::field_descriptions)
```

```{r sch2020 creation}
sch2020 <- fast_scraper_schedules(2020)
```


```{r homewins20 creation}
homewins20 <- sch2020 %>%
  filter(game_type == 'REG') %>%
  mutate(homewin = ifelse(home_result > 0, 1, 0),
         viswin = ifelse(home_result < 0, 1, 0),
         gmtie = ifelse(home_result == 0, 1, 0),
         team = home_team) %>%
  filter(homewin == 1) %>%
  group_by(team) %>%
  summarise(wins.at.home = sum(homewin))
```

```{r viswins20 creation}
viswins20 <- sch2020 %>%
  filter(game_type == 'REG') %>%
  mutate(homewin = ifelse(home_result > 0, 1, 0),
         viswin = ifelse(home_result < 0, 1, 0),
         gmtie = ifelse(home_result == 0, 1, 0),
         team = away_team) %>%
  filter(viswin == 1) %>%
  group_by(team) %>%
  summarise(wins.at.away = sum(viswin))
```

```{r ties20 creation}
hometies20 <- sch2020 %>%
  filter(game_type == 'REG') %>%
  mutate(homewin = ifelse(home_result > 0, 1, 0),
         viswin = ifelse(home_result < 0, 1, 0),
         gmtie = ifelse(home_result == 0, 1, 0),
         team = home_team) %>%
  filter(gmtie == 1) %>%
  group_by(team) %>%
  summarise(tie = sum(gmtie))

visties20 <- sch2020 %>%
  filter(game_type == 'REG') %>%
  mutate(homewin = ifelse(home_result > 0, 1, 0),
         viswin = ifelse(home_result < 0, 1, 0),
         gmtie = ifelse(home_result == 0, 1, 0),
         team = away_team) %>%
  filter(gmtie == 1) %>%
  group_by(team) %>%
  summarise(tie = sum(gmtie))

ties20 <- hometies20 %>%
  rbind(visties20)
```

```{r teamstandings20 creation}
teamstandings20 <- homewins20 %>%
  left_join(viswins20) %>%
  left_join(ties20) %>%
  mutate(tie = ifelse(is.na(tie) == TRUE, 0, tie),
         wins.at.home = ifelse(is.na(wins.at.home) == TRUE, 0, wins.at.home),
         wins.at.away = ifelse(is.na(wins.at.away) == TRUE, 0, wins.at.away),
         wins = wins.at.away + wins.at.home,
         loss = 16 - (wins + tie)) %>%
  select(team, wins, loss, tie)
```



## Part 3

Below we have the the amount of wins for each team in the 2020 season, using this prior knowledgue of team quality will help to inform us of future game win probability. 

```{r}
data_new <- load_pbp(2020)
```


```{r}
halftime_score_diff_2020 <- data_new %>%
  filter(half_seconds_remaining == 0 & game_half == "Half1" & season_type == "REG")%>%
  mutate(score_differential = total_home_score - total_away_score)%>%
  select(game_id, home_team, away_team, game_half, score_differential)
```


```{r}
end_score_diff_2020 <- data_new %>%
  filter(half_seconds_remaining == 0 & game_half == "Half2" & season_type == "REG")%>%
  mutate(score_differential = total_home_score- total_away_score)%>%
  select(game_id, home_team, away_team, score_differential) %>%
  mutate(home_team_win = if_else(score_differential > 0, 1, 0))

score_diff_data <- halftime_score_diff_2020 %>%
  inner_join(end_score_diff_2020, by = "game_id")

first_q_diff <- data_new %>%
  filter(quarter_end == 1 & qtr == 1 & season_type == "REG") %>%
  mutate(score_differential = total_home_score- total_away_score)%>%
  select(game_id, home_team, away_team, score_differential)

second_q_diff <- data_new %>%
  filter(quarter_end == 1 & qtr == 2 & season_type == "REG") %>%
  mutate(score_differential = total_home_score- total_away_score)%>%
  select(game_id, home_team, away_team, score_differential) 

third_q_diff <- data_new %>%
  filter(quarter_end == 1 & qtr == 3 & season_type == "REG") %>%
  mutate(score_differential = total_home_score- total_away_score)%>%
  select(game_id, home_team, away_team, score_differential)

fourth_q_diff <- data_new %>%
  filter(quarter_end == 1 & qtr == 4 & season_type == "REG") %>%
  mutate(score_differential = total_home_score- total_away_score)%>%
  select(game_id, home_team, away_team, score_differential) %>%
  mutate(home_team_win = if_else(score_differential > 0, 1, 0))

quarter_score_diff <- first_q_diff %>%
  inner_join(second_q_diff, by = "game_id") %>%
   inner_join(third_q_diff, by = "game_id") %>%
   inner_join(end_score_diff_2020, by = "game_id") 


```

```{r}
teamstandings20 <- teamstandings20 %>%
  left_join(teams_colors_logos, by = c("team" = "team_abbr"))
  

ggplot(teamstandings20) + 
  aes(x = team, y = wins) + 
  geom_col(fill = teamstandings20$team_color) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


```{r}
score_diff_data %>%
  ggplot() + 
  aes(x = score_differential.y) + 
  geom_histogram(binwidth = 7)
```

This graph above shows us that there is quite a lot of parity in the league making every score in our model matter a lot. 


```{r}
data_new %>%
  filter(game_id == "2020_01_ARI_SF") %>%
  ggplot() + 
  aes(x = game_seconds_remaining, y = total_home_epa ) + 
  geom_line()
```

This graph shows us the epa or expected points added by each play throughout a game. This gives us insight into how the home team did throughout the game which will help us predict each teams win probability thorughout the game. 

```{r}
data_new %>%
  filter(game_id == "2020_01_ARI_SF") %>%
  ggplot() + 
  aes(x = game_seconds_remaining, y = home_wp) + 
  geom_line()
```

This is a win probability graph. This is ultimately what we would like to build up to and create, this was made by NFLFastR, and is something that we hope to be able to create ultimately. 



## Part 4

OUr first model is a basic logistic regression model that predicts who will win the game based on the halftime score. This is a very basic model to get us started that will help us with the frame work as we build it into a more complex model. 

```{r}
week_1 <- stan_glm(
  home_team_win~ score_differential.x,
  data = score_diff_data,
  family = binomial,
  chains = 4, iter = 5000*2, seed = 84735, refresh = 0
)

week_1
```

The centered intercept tells us about the log odds of the winning probability. 

```{r}

pp_check(week_1)
```


## Part 5

Our next steps are to finish creating our prior analysis on how good each team is and then we will complicate our model more and we may try to create a shiny app to make our model more interactive so that people can enter certain teams and game situations to predict the win probability for a certain team. 


```{r}
hierarchical_quarter_model <- stan_glm(home_team_win ~ score_differential.x + 
                                        score_differential.y +
                                        score_differential.x.x, 
                                      data = quarter_score_diff, 
                                      family = binomial,
  chains = 4, iter = 5000*2, seed = 84735, refresh = 0)
```


```{r}
pp_check(hierarchical_quarter_model)
```

```{r}
classification_summary(hierarchical_quarter_model, quarter_score_diff)


```


```{r}
library(naniar)
```


```{r}
data_new_2 <- data_new %>%
  mutate(field_goal_result_ = if_else(field_goal_result == "made", 1, 0)) %>%
  mutate(field_goal_result_ = if_else(is.na(field_goal_result_), 0, 1)) %>%
  mutate(extra_point_result_ = if_else(extra_point_result == "good", 1, 0)) %>%
  mutate(extra_point_result_ = if_else(is.na(extra_point_result_) , 0, 1)) %>%
  mutate(two_point_conv_result_ = if_else(two_point_conv_result == "success", 1, 0)) %>%
  mutate(two_point_conv_result_ = if_else(is.na(two_point_conv_result_), 0, 1)) 
  
  
home_win_data <-data_new_2 %>%
  filter(game_seconds_remaining == 0 & season_type == "REG") %>%
  mutate(score_differential_ = home_score - away_score) %>%
  mutate(home_team_win = if_else(score_differential_ > 0, 1, 0)) %>%
  select(game_id, home_team_win)
  


scoring_play_data<- data_new_2  %>%
  left_join(home_win_data, by = "game_id") %>%
  filter(field_goal_result_ == 1 |
           extra_point_result_ == 1 |
           touchdown == 1 |
           two_point_conv_result_ == 1 |
           safety == 1) %>%
  select(home_team, away_team, field_goal_result_, extra_point_result_, touchdown, two_point_conv_result_, safety, game_id, home_score, away_score, home_team_win, score_differential_post)


scoring_play_data %>%
  add_n

```




```{r}
scoring_play_model <- stan_glm(home_team_win ~ score_differential_post, 
                               data = scoring_play_data, 
                               family = binomial, 
                               chains = 4,
                               iter = 5000*2,
                               seed = 84735, 
                               refresh = 0)
```



```{r}
pp_check(scoring_play_model)
```


```{r}
classification_summary(scoring_play_model, scoring_play_data)
```

